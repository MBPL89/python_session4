{"title":"4. Strings Practice","markdown":{"yaml":{"title":"4. Strings Practice","author":"Dr. Piccoli","format":"live-html","pyodide":{"packages":["seaborn"]},"editor_options":{"chunk_output_type":"console"}},"containsRefs":false,"markdown":"\n\n```{=html}\n<style>\n/* Target the first tab (Demo) */\n.nav-pills .nav-item:nth-child(1) .nav-link {\n  background-color: #FFC20A; /* Yellow */\n  color: white;\n}\n\n/* Target the second tab (Example) */\n.nav-pills .nav-item:nth-child(2) .nav-link {\n  background-color: #5D3A9B; /* Purple */\n  color: white;\n}\n\n/* Target the third tab (Exercise) */\n.nav-pills .nav-item:nth-child(3) .nav-link {\n  background-color: #0C7BDC; /* Blue */\n  color: white;\n}\n\n/* Target the fourth tab (Activity) */\n.nav-pills .nav-item:nth-child(4) .nav-link {\n  background-color: #E66100; /* Orange */\n  color: white;\n}\n\n/* Target the fifth tab (Activity2) */\n.nav-pills .nav-item:nth-child(5) .nav-link {\n  background-color: #40B0A6; /* teal */\n  color: white;\n}\n\n/* Active tab styling */\n.nav-pills .nav-link.active {\n  background-color: #2E7D32; /* Customize active tab color */\n  color: white;\n}\n</style>\n```\n\n{{< include ./_extensions/r-wasm/live/_knitr.qmd >}} {{< include ./_extensions/r-wasm/live/_gradethis.qmd >}}\n\n```{pyodide}\n#| autorun: true\n#| startover: false\n#| edit: false\n#| runbutton: false\n#| echo: false\nimport sys\nfrom io import StringIO\n\n```\n\n1) **Title Fixer:** You receive a list of messy book titles like [\"tHe gReaT GaTsBy\", \"cAtcHer in the rYe\"]. Write a function that returns each title with only the first letter capitalized and the rest in lowercase. \n\n**Tip:** Use `str.capitalize()`\n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"tHe gReaT GaTsBy\\ncAtcHer in the rYe\\nI malaVOglia\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n2) **Centered Banner Generator:** Create a function that takes a word and prints it as a banner, centered in a width of 30 using * as the fill character. \n\n**Tip:** Use `str.center(width[, fillchar])` \n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"...\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n3) **File Filter:** Given a list of filenames, print only those that end with .jpg or .png with an appropriate message. \n\n**Tip:** Use `str.endswith(suffix[, start[, end]])` \n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\nfiles = [\"photo.jpg\", \"document.pdf\", \"image.png\", \"notes.txt\"]\n\n\n\n```\n\n4) **Clean-Up on the Left:** You’re given strings like `\"---Warning!\"` or `\"***Important Notice\"`. Strip out all leading special characters (-, *, etc.) and return the cleaned string. \n\n**Tip:** Use `str.lstrip([chars])` \n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n5) **Censorship Machine:** Censor any inappropriate words in a user input string (e.g., replace `\"darn\"` with `\"****\"`). Optionally, only replace the first occurrence. \n\n**Tip:** Use `str.replace(old, new[, count])` \n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"This is a fooking mess. Darn it! Shooot, what a fook! Darn fook fooking shooot.\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n6) **Letter counter:** A secret message is sent with random capitalizations by the zodiac killer. You need to count the number of \"k\" and \"m\" (for kill and murder) in the text. It does not matter if they are capitalized or not, any occurrence of the letter needs to be counted. Use the functions you deem best for the job. \n\n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"K...k...M...m...KaBoom. Must Kill Many More.\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n7) **Shouting Bot:** Make a function that takes a sentence and “shouts” it in all caps, adding three exclamation points at the end. \n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"K...k...M...m...KaBoom. Must Kill Many More.\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n8)  Find and slice. Use find and string slicing to extract the portion of the string after the colon character and then use the float function to convert the extracted string into a floating point number.\n\n    In the second cell below, generalize this algorithm. It should loop through the three strings provided in input and ensure that there is a \":\" before extracting, converting and printing the number.\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n9)  Create a program that, collects user input until the user types \"done\".\n\n    Given any string in input will first check for the length of the string. If the string in less than 5 characters long, it prints the message \"Can't do anything with such a short string, try harder!\"\n\n    When the string is longer than 5 character, then the program will slice the string and only extract the middle five characters.\n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"...\\n...\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n10)  Create a program that, collects user input until the user types \"done\".\n\n    For each string in input, first, strip any white space at the beginning or the end of the string. Then delete all the vowels from the string and print the resulting string.\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n11) **Count Vowels in a String** Create a function `count_vowels(text)` that counts the number of vowels (a, e, i, o, u) in a given string. Use a for loop and conditional statements to accomplish the task.\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n\n```\n\n12) **Password Strength Checker**\nWrite a function `check_password_strength(password)` that evaluates a password. Then test it on three passwords of your choice. The rules are:\n* If it's less than 6 characters → \"Weak\"\n* If it's between 6-10 characters → \"Moderate\"\n* If it's more than 10 characters → \"Strong\"\n\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```","srcMarkdownNoYaml":"\n\n```{=html}\n<style>\n/* Target the first tab (Demo) */\n.nav-pills .nav-item:nth-child(1) .nav-link {\n  background-color: #FFC20A; /* Yellow */\n  color: white;\n}\n\n/* Target the second tab (Example) */\n.nav-pills .nav-item:nth-child(2) .nav-link {\n  background-color: #5D3A9B; /* Purple */\n  color: white;\n}\n\n/* Target the third tab (Exercise) */\n.nav-pills .nav-item:nth-child(3) .nav-link {\n  background-color: #0C7BDC; /* Blue */\n  color: white;\n}\n\n/* Target the fourth tab (Activity) */\n.nav-pills .nav-item:nth-child(4) .nav-link {\n  background-color: #E66100; /* Orange */\n  color: white;\n}\n\n/* Target the fifth tab (Activity2) */\n.nav-pills .nav-item:nth-child(5) .nav-link {\n  background-color: #40B0A6; /* teal */\n  color: white;\n}\n\n/* Active tab styling */\n.nav-pills .nav-link.active {\n  background-color: #2E7D32; /* Customize active tab color */\n  color: white;\n}\n</style>\n```\n\n{{< include ./_extensions/r-wasm/live/_knitr.qmd >}} {{< include ./_extensions/r-wasm/live/_gradethis.qmd >}}\n\n```{pyodide}\n#| autorun: true\n#| startover: false\n#| edit: false\n#| runbutton: false\n#| echo: false\nimport sys\nfrom io import StringIO\n\n```\n\n1) **Title Fixer:** You receive a list of messy book titles like [\"tHe gReaT GaTsBy\", \"cAtcHer in the rYe\"]. Write a function that returns each title with only the first letter capitalized and the rest in lowercase. \n\n**Tip:** Use `str.capitalize()`\n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"tHe gReaT GaTsBy\\ncAtcHer in the rYe\\nI malaVOglia\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n2) **Centered Banner Generator:** Create a function that takes a word and prints it as a banner, centered in a width of 30 using * as the fill character. \n\n**Tip:** Use `str.center(width[, fillchar])` \n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"...\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n3) **File Filter:** Given a list of filenames, print only those that end with .jpg or .png with an appropriate message. \n\n**Tip:** Use `str.endswith(suffix[, start[, end]])` \n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\nfiles = [\"photo.jpg\", \"document.pdf\", \"image.png\", \"notes.txt\"]\n\n\n\n```\n\n4) **Clean-Up on the Left:** You’re given strings like `\"---Warning!\"` or `\"***Important Notice\"`. Strip out all leading special characters (-, *, etc.) and return the cleaned string. \n\n**Tip:** Use `str.lstrip([chars])` \n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n5) **Censorship Machine:** Censor any inappropriate words in a user input string (e.g., replace `\"darn\"` with `\"****\"`). Optionally, only replace the first occurrence. \n\n**Tip:** Use `str.replace(old, new[, count])` \n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"This is a fooking mess. Darn it! Shooot, what a fook! Darn fook fooking shooot.\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n6) **Letter counter:** A secret message is sent with random capitalizations by the zodiac killer. You need to count the number of \"k\" and \"m\" (for kill and murder) in the text. It does not matter if they are capitalized or not, any occurrence of the letter needs to be counted. Use the functions you deem best for the job. \n\n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"K...k...M...m...KaBoom. Must Kill Many More.\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n7) **Shouting Bot:** Make a function that takes a sentence and “shouts” it in all caps, adding three exclamation points at the end. \n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"K...k...M...m...KaBoom. Must Kill Many More.\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n8)  Find and slice. Use find and string slicing to extract the portion of the string after the colon character and then use the float function to convert the extracted string into a floating point number.\n\n    In the second cell below, generalize this algorithm. It should loop through the three strings provided in input and ensure that there is a \":\" before extracting, converting and printing the number.\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n9)  Create a program that, collects user input until the user types \"done\".\n\n    Given any string in input will first check for the length of the string. If the string in less than 5 characters long, it prints the message \"Can't do anything with such a short string, try harder!\"\n\n    When the string is longer than 5 character, then the program will slice the string and only extract the middle five characters.\n\n```{pyodide}\n#| persist: true\n#| autorun: false\n#| min-lines: 3\nmock_input = StringIO(\"...\\n...\\n\")\nsys.stdin = mock_input\n```\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n10)  Create a program that, collects user input until the user types \"done\".\n\n    For each string in input, first, strip any white space at the beginning or the end of the string. Then delete all the vowels from the string and print the resulting string.\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```\n\n11) **Count Vowels in a String** Create a function `count_vowels(text)` that counts the number of vowels (a, e, i, o, u) in a given string. Use a for loop and conditional statements to accomplish the task.\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n\n```\n\n12) **Password Strength Checker**\nWrite a function `check_password_strength(password)` that evaluates a password. Then test it on three passwords of your choice. The rules are:\n* If it's less than 6 characters → \"Weak\"\n* If it's between 6-10 characters → \"Moderate\"\n* If it's more than 10 characters → \"Strong\"\n\n\n```{pyodide}\n#| persist: true\n#| startover: false\n#| autorun: false\n#| min-lines: 3\n\n```"},"formats":{"live-html":{"identifier":{"display-name":"HTML","target-format":"live-html","base-format":"html","extension-name":"live"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["C:\\Users\\admin\\OneDrive\\Working\\Teaching\\Coding\\python_session4\\_extensions\\r-wasm\\live\\live.lua"],"output-file":"p5-strings.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","ojs-engine":true,"revealjs-plugins":[],"editor":"visual","draft-mode":"gone","drafts":["p5-strings-solved.qmd","challenge2-strings_solved.qmd"],"title":"4. Strings Practice","author":"Dr. Piccoli","pyodide":{"packages":["seaborn"]},"editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}